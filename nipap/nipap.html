

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>NIPAP API &mdash; NIPAP 1.0 documentation</title>
    
    <link rel="stylesheet" href="static/default.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <link rel="top" title="NIPAP 1.0 documentation" href="index.html" />
    <link rel="next" title="XML-RPC glue class" href="xmlrpc.html" />
    <link rel="prev" title="Design choices" href="design.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="xmlrpc.html" title="XML-RPC glue class"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="design.html" title="Design choices"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">NIPAP 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="module-nipap.nipap"></span><div class="section" id="nipap-api">
<h1>NIPAP API<a class="headerlink" href="#nipap-api" title="Permalink to this headline">¶</a></h1>
<p>This module contains the Nipap class which provides most of the logic in
NIPAP apart from that contained within the PostgreSQL database.</p>
<p>NIPAP contains three types of objects: VRFs, prefixes and pools.</p>
<div class="section" id="vrf">
<h2>VRF<a class="headerlink" href="#vrf" title="Permalink to this headline">¶</a></h2>
<p>A VRF represents a Virtual Routing and Forwarding instance. By default, one
VRF which represents the global routing table (&#8220;no VRF&#8221;) is defined. This
ID always has the ID 0.</p>
<div class="section" id="vrf-attributes">
<h3>VRF attributes<a class="headerlink" href="#vrf-attributes" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">id</span></tt> - ID number of the VRF.</p>
</li>
<li><dl class="first docutils">
<dt><tt class="xref py py-attr docutils literal"><span class="pre">vrf</span></tt> - The VRF RDs administrator and assigned number subfields</dt>
<dd><p class="first last">(eg. 65000:123).</p>
</dd>
</dl>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">name</span></tt> - A short name, such as &#8216;VPN Customer A&#8217;.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">description</span></tt> - A longer description of what the VRF is used for.</p>
</li>
</ul>
</div>
<div class="section" id="vrf-functions">
<h3>VRF functions<a class="headerlink" href="#vrf-functions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference internal" href="#nipap.nipap.Nipap.list_vrf" title="nipap.nipap.Nipap.list_vrf"><tt class="xref py py-func docutils literal"><span class="pre">list_vrf()</span></tt></a> - Return a list of VRFs.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.add_vrf" title="nipap.nipap.Nipap.add_vrf"><tt class="xref py py-func docutils literal"><span class="pre">add_vrf()</span></tt></a> - Create a new VRF.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.edit_vrf" title="nipap.nipap.Nipap.edit_vrf"><tt class="xref py py-func docutils literal"><span class="pre">edit_vrf()</span></tt></a> - Edit a VRF.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.remove_vrf" title="nipap.nipap.Nipap.remove_vrf"><tt class="xref py py-func docutils literal"><span class="pre">remove_vrf()</span></tt></a> - Remove a VRF.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.search_vrf" title="nipap.nipap.Nipap.search_vrf"><tt class="xref py py-func docutils literal"><span class="pre">search_vrf()</span></tt></a> - Search VRFs based on a formatted dict.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.smart_search_vrf" title="nipap.nipap.Nipap.smart_search_vrf"><tt class="xref py py-func docutils literal"><span class="pre">smart_search_vrf()</span></tt></a> - Search VRFs based on a query string.</li>
</ul>
</div>
</div>
<div class="section" id="prefix">
<h2>Prefix<a class="headerlink" href="#prefix" title="Permalink to this headline">¶</a></h2>
<p>A prefix object defines an address prefix. Prefixes can be one of three
different types; reservation, assignment or host.
Reservation; a prefix which is reserved for future use.
Assignment; addresses assigned to a specific purpose.
Host; prefix of max length within an assigment, assigned to an end host.</p>
<div class="section" id="prefix-attributes">
<h3>Prefix attributes<a class="headerlink" href="#prefix-attributes" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">id</span></tt> - ID number of the prefix.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">prefix</span></tt> - The IP prefix itself.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">display_prefix</span></tt> - A more user-friendly version of the prefix.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">family</span></tt> - Address family (integer 4 or 6). Set by NIPAP.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">vrf_id</span></tt> - ID of the VRF which the prefix belongs to.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">vrf_rt</span></tt> - RT of the VRF which the prefix belongs to.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">vrf_name</span></tt> - Name of VRF which the prefix belongs to.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">description</span></tt> - A short description of the prefix.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">comment</span></tt> - A longer text describing the prefix and its use.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">node</span></tt> - Name of the node on which the address is configured.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">pool_id</span></tt> - ID of pool, if the prefix belongs to a pool.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">pool_name</span></tt> - Name of pool, if the prefix belongs to a pool.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">type</span></tt> - Prefix type, string &#8216;reservation&#8217;, &#8216;assignment&#8217; or &#8216;host&#8217;.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">indent</span></tt> - Depth in prefix tree. Set by NIPAP.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">country</span></tt> - Two letter country code where the prefix resides.</p>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">order_id</span></tt> - Order identifier.</p>
</li>
<li><dl class="first docutils">
<dt><tt class="xref py py-attr docutils literal"><span class="pre">external_key</span></tt> - A field for use by external systems which needs to</dt>
<dd><p class="first last">store references to its own dataset.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="xref py py-attr docutils literal"><span class="pre">authoritative_source</span></tt> - String identifying which system last</dt>
<dd><p class="first last">modified the prefix.</p>
</dd>
</dl>
</li>
<li><p class="first"><tt class="xref py py-attr docutils literal"><span class="pre">alarm_priority</span></tt> - String &#8216;low&#8217;, &#8216;medium&#8217; or &#8216;high&#8217;.</p>
</li>
<li><dl class="first docutils">
<dt><tt class="xref py py-attr docutils literal"><span class="pre">monitor</span></tt> - A boolean specifying whether the prefix should be</dt>
<dd><p class="first last">monitored or not.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="xref py py-attr docutils literal"><span class="pre">display</span></tt> - Only set by the <a class="reference internal" href="#nipap.nipap.Nipap.search_prefix" title="nipap.nipap.Nipap.search_prefix"><tt class="xref py py-func docutils literal"><span class="pre">search_prefix()</span></tt></a> and</dt>
<dd><p class="first last"><a class="reference internal" href="#nipap.nipap.Nipap.smart_search_prefix" title="nipap.nipap.Nipap.smart_search_prefix"><tt class="xref py py-func docutils literal"><span class="pre">smart_search_prefix()</span></tt></a> functions, see their documentation for
explanation.</p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="prefix-functions">
<h3>Prefix functions<a class="headerlink" href="#prefix-functions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference internal" href="#nipap.nipap.Nipap.list_prefix" title="nipap.nipap.Nipap.list_prefix"><tt class="xref py py-func docutils literal"><span class="pre">list_prefix()</span></tt></a> - Return a list of prefixes.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.add_prefix" title="nipap.nipap.Nipap.add_prefix"><tt class="xref py py-func docutils literal"><span class="pre">add_prefix()</span></tt></a> - Add a prefix, more or less automatically.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.edit_prefix" title="nipap.nipap.Nipap.edit_prefix"><tt class="xref py py-func docutils literal"><span class="pre">edit_prefix()</span></tt></a> - Edit a prefix.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.remove_prefix" title="nipap.nipap.Nipap.remove_prefix"><tt class="xref py py-func docutils literal"><span class="pre">remove_prefix()</span></tt></a> - Remove a prefix.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.search_prefix" title="nipap.nipap.Nipap.search_prefix"><tt class="xref py py-func docutils literal"><span class="pre">search_prefix()</span></tt></a> - Search prefixes based on a formatted dict.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.smart_search_prefix" title="nipap.nipap.Nipap.smart_search_prefix"><tt class="xref py py-func docutils literal"><span class="pre">smart_search_prefix()</span></tt></a> - Search prefixes based on a string.</li>
</ul>
</div>
</div>
<div class="section" id="pool">
<h2>Pool<a class="headerlink" href="#pool" title="Permalink to this headline">¶</a></h2>
<p>Reserved prefixes can be gathered in a pool which then can be used when
adding prefixes. The <cite>add_prefix</cite> can for example be asked to return a
prefix from the pool CORE-LOOPBACKS. Then all the prefix member of this pool
will be examined for a suitable prefix with the default length specified in
the pool if nothing else is given.</p>
<div class="section" id="pool-attributes">
<h3>Pool attributes<a class="headerlink" href="#pool-attributes" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><tt class="xref py py-attr docutils literal"><span class="pre">id</span></tt> - ID number of the pool.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">name</span></tt> - A short name.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">description</span></tt> - A longer description of the pool.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">default_type</span></tt> - Default prefix type (see prefix types above.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">ipv4_default_prefix_length</span></tt> - Default prefix length of IPv4 prefixes.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">ipv6_default_prefix_length</span></tt> - Default prefix length of IPv6 prefixes.</li>
</ul>
</div>
<div class="section" id="pool-functions">
<h3>Pool functions<a class="headerlink" href="#pool-functions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference internal" href="#nipap.nipap.Nipap.list_pool" title="nipap.nipap.Nipap.list_pool"><tt class="xref py py-func docutils literal"><span class="pre">list_pool()</span></tt></a> - Return a list of pools.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.add_pool" title="nipap.nipap.Nipap.add_pool"><tt class="xref py py-func docutils literal"><span class="pre">add_pool()</span></tt></a> - Add a pool.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.edit_pool" title="nipap.nipap.Nipap.edit_pool"><tt class="xref py py-func docutils literal"><span class="pre">edit_pool()</span></tt></a> - Edit a pool.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.remove_pool" title="nipap.nipap.Nipap.remove_pool"><tt class="xref py py-func docutils literal"><span class="pre">remove_pool()</span></tt></a> - Remove a pool.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.search_pool" title="nipap.nipap.Nipap.search_pool"><tt class="xref py py-func docutils literal"><span class="pre">search_pool()</span></tt></a> - Search pools based on a formatted dict.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.smart_search_pool" title="nipap.nipap.Nipap.smart_search_pool"><tt class="xref py py-func docutils literal"><span class="pre">smart_search_pool()</span></tt></a> - Search pools based on a string.</li>
</ul>
</div>
</div>
<div class="section" id="asn">
<h2>ASN<a class="headerlink" href="#asn" title="Permalink to this headline">¶</a></h2>
<p>An ASN object represents an Autonomous System Number (ASN).</p>
<div class="section" id="asn-attributes">
<h3>ASN attributes<a class="headerlink" href="#asn-attributes" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><tt class="xref py py-attr docutils literal"><span class="pre">asn</span></tt> - AS number.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">name</span></tt> - A name of the AS number.</li>
</ul>
</div>
<div class="section" id="asn-functions">
<h3>ASN functions<a class="headerlink" href="#asn-functions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference internal" href="#nipap.nipap.Nipap.list_asn" title="nipap.nipap.Nipap.list_asn"><tt class="xref py py-func docutils literal"><span class="pre">list_asn()</span></tt></a> - Return a list of ASNs.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.add_asn" title="nipap.nipap.Nipap.add_asn"><tt class="xref py py-func docutils literal"><span class="pre">add_asn()</span></tt></a> - Add an ASN.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.edit_asn" title="nipap.nipap.Nipap.edit_asn"><tt class="xref py py-func docutils literal"><span class="pre">edit_asn()</span></tt></a> - Edit an ASN.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.remove_asn" title="nipap.nipap.Nipap.remove_asn"><tt class="xref py py-func docutils literal"><span class="pre">remove_asn()</span></tt></a> - Remove an ASN.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.search_asn" title="nipap.nipap.Nipap.search_asn"><tt class="xref py py-func docutils literal"><span class="pre">search_asn()</span></tt></a> - Search ASNs based on a formatted dict.</li>
<li><a class="reference internal" href="#nipap.nipap.Nipap.smart_search_asn" title="nipap.nipap.Nipap.smart_search_asn"><tt class="xref py py-func docutils literal"><span class="pre">smart_search_asn()</span></tt></a> - Search ASNs based on a string.</li>
</ul>
</div>
</div>
<div class="section" id="the-spec">
<h2>The &#8216;spec&#8217;<a class="headerlink" href="#the-spec" title="Permalink to this headline">¶</a></h2>
<p>Central to the use of the NIPAP API is the spec &#8211; the specifier. It is used
by many functions to in a more dynamic way specify what element(s) you want
to select. Mainly it came to be due to the use of two attributes which can
be thought of as primary keys for an object, such as a pool&#8217;s <tt class="xref py py-attr docutils literal"><span class="pre">id</span></tt> and
<tt class="xref py py-attr docutils literal"><span class="pre">name</span></tt> attribute. They are however implemented so that you can use
more or less any attribute in the spec, to be able to for example get all
prefixes of family 6 with type reservation.</p>
<p>The spec is a dict formatted as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">vrf_spec</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;id&#39;</span><span class="p">:</span> <span class="mi">512</span>
<span class="p">}</span>
</pre></div>
</div>
<p>But can also be elaborated somehwat for certain objects, as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">prefix_spec</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;family&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
    <span class="s">&#39;type&#39;</span><span class="p">:</span> <span class="s">&#39;reservation&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If multiple keys are given, they will be ANDed together.</p>
</div>
<div class="section" id="authorization-accounting">
<h2>Authorization &amp; accounting<a class="headerlink" href="#authorization-accounting" title="Permalink to this headline">¶</a></h2>
<p>With each query an object extending the BaseAuth class should be passed.
This object is used in the Nipap class to perform authorization (not yet
implemented) and accounting. Authentication should be performed at an
earlier stage and is NOT done in the Nipap class.</p>
<p>Each command which alters data stored in NIPAP is logged. There are
currently no API functions for extracting this data, but this will change
in the future.</p>
</div>
<div class="section" id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nipap.nipap.Inet">
<em class="property">class </em><tt class="descclassname">nipap.nipap.</tt><tt class="descname">Inet</tt><big>(</big><em>addr</em><big>)</big><a class="headerlink" href="#nipap.nipap.Inet" title="Permalink to this definition">¶</a></dt>
<dd><p>This works around a bug in psycopg2 version somewhere before 2.4.  The
__init__ function in the original class is broken and so this is merely
a copy with the bug fixed.</p>
<p>Wrap a string to allow for correct SQL-quoting of inet values.</p>
<p>Note that this adapter does NOT check the passed value to make sure it
really is an inet-compatible address but DOES call adapt() on it to make
sure it is impossible to execute an SQL-injection by passing an evil
value to the initializer.</p>
</dd></dl>

<dl class="class">
<dt id="nipap.nipap.Nipap">
<em class="property">class </em><tt class="descclassname">nipap.nipap.</tt><tt class="descname">Nipap</tt><a class="headerlink" href="#nipap.nipap.Nipap" title="Permalink to this definition">¶</a></dt>
<dd><p>Main NIPAP class.</p>
<p>The main NIPAP class containing all API methods. When creating an
instance, a database connection object is created which is used during
the instance&#8217;s lifetime.</p>
<dl class="method">
<dt id="nipap.nipap.Nipap.add_asn">
<tt class="descname">add_asn</tt><big>(</big><em>auth</em>, <em>attr</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.add_asn" title="Permalink to this definition">¶</a></dt>
<dd><p>Add AS number to NIPAP.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>attr</cite> [asn_attr]</dt>
<dd><p class="first last">ASN attributes.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns a dict describing the ASN which was added.</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.add_pool">
<tt class="descname">add_pool</tt><big>(</big><em>auth</em>, <em>attr</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.add_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a pool according to <cite>attr</cite>.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>attr</cite> [pool_attr]</dt>
<dd><p class="first last">A dict containing the attributes the new pool should have.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns a dict describing the pool which was added.</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.add_prefix">
<tt class="descname">add_prefix</tt><big>(</big><em>auth</em>, <em>attr</em>, <em>args={}</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.add_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a prefix and return its ID.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>attr</cite> [prefix_attr]</dt>
<dd><p class="first last">Prefix attributes.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>args</cite> [add_prefix_args]</dt>
<dd><p class="first last">Arguments explaining how the prefix should be allocated.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns a dict describing the prefix which was added.</p>
<p>Prefixes can be added in three ways; manually, from a pool or
from a prefix.</p>
<dl class="docutils">
<dt>Manually</dt>
<dd>All prefix data, including the prefix itself is specified in the
<cite>attr</cite> argument. The <cite>args</cite> argument shall be omitted.</dd>
<dt>From a pool</dt>
<dd>Most prefixes are expected to be automatically assigned from a pool.
In this case, the <tt class="xref py py-attr docutils literal"><span class="pre">prefix</span></tt> key is omitted from the <cite>attr</cite> argument.
Also the <tt class="xref py py-attr docutils literal"><span class="pre">type</span></tt> key can be omitted and the prefix type will then be
set to the pools default prefix type. The <a class="reference internal" href="#nipap.nipap.Nipap.find_free_prefix" title="nipap.nipap.Nipap.find_free_prefix"><tt class="xref py py-func docutils literal"><span class="pre">find_free_prefix()</span></tt></a>
function is used to find available prefixes for this allocation
method, see its documentation for a description of how the
<cite>args</cite> argument should be formatted.</dd>
<dt>From a prefix</dt>
<dd>A prefix can also be selected from another prefix. Also in this case
the <tt class="xref py py-attr docutils literal"><span class="pre">prefix</span></tt> key is omitted from the <cite>attr</cite> argument. See the
documentation for the <a class="reference internal" href="#nipap.nipap.Nipap.find_free_prefix" title="nipap.nipap.Nipap.find_free_prefix"><tt class="xref py py-func docutils literal"><span class="pre">find_free_prefix()</span></tt></a> for a description of how
the <cite>args</cite> argument is to be formatted.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.add_vrf">
<tt class="descname">add_vrf</tt><big>(</big><em>auth</em>, <em>attr</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.add_vrf" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new VRF.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>attr</cite> [vrf_attr]</dt>
<dd><p class="first last">The news VRF&#8217;s attributes.</p>
</dd>
</dl>
</li>
</ul>
<p>Add a VRF based on the values stored in the <cite>attr</cite> dict.</p>
<p>Returns a dict describing the VRF which was added.</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.edit_asn">
<tt class="descname">edit_asn</tt><big>(</big><em>auth</em>, <em>asn</em>, <em>attr</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.edit_asn" title="Permalink to this definition">¶</a></dt>
<dd><p>Edit AS number</p>
<ul class="simple">
<li><cite>auth</cite> [BaseAuth] AAA options.</li>
<li><cite>asn</cite> [integer] AS number to edit.</li>
<li><cite>attr</cite> [asn_attr] New AS attributes.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.edit_pool">
<tt class="descname">edit_pool</tt><big>(</big><em>auth</em>, <em>spec</em>, <em>attr</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.edit_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Update pool given by <cite>spec</cite> with attributes <cite>attr</cite>.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>spec</cite> [pool_spec]</dt>
<dd><p class="first last">Specifies what pool to edit.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>attr</cite> [pool_attr]</dt>
<dd><p class="first last">Attributes to update and their new values.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.edit_prefix">
<tt class="descname">edit_prefix</tt><big>(</big><em>auth</em>, <em>spec</em>, <em>attr</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.edit_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Update prefix matching <cite>spec</cite> with attributes <cite>attr</cite>.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>spec</cite> [prefix_spec]</dt>
<dd><p class="first last">Specifies the prefix to edit.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>attr</cite> [prefix_attr]</dt>
<dd><p class="first last">Prefix attributes.</p>
</dd>
</dl>
</li>
</ul>
<p>Note that there are restrictions on when and how a prefix&#8217;s type
can be changed; reservations can be changed to assignments and vice
versa, but only if they contain no child prefixes.</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.edit_vrf">
<tt class="descname">edit_vrf</tt><big>(</big><em>auth</em>, <em>spec</em>, <em>attr</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.edit_vrf" title="Permalink to this definition">¶</a></dt>
<dd><p>Update VRFs matching <cite>spec</cite> with attributes <cite>attr</cite>.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>spec</cite> [vrf_spec]</dt>
<dd><p class="first last">Attibutes specifying what VRF to edit.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>attr</cite> [vrf_attr]</dt>
<dd><p class="first last">Dict specifying fields to be updated and their new values.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.find_free_prefix">
<tt class="descname">find_free_prefix</tt><big>(</big><em>auth</em>, <em>vrf</em>, <em>args</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.find_free_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds free prefixes in the sources given in <cite>args</cite>.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>vrf</cite> [vrf]</dt>
<dd><p class="first last">Full VRF-dict specifying in which VRF the prefix should be
unique.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>args</cite> [find_free_prefix_args]</dt>
<dd><p class="first last">Arguments to the find free prefix function.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns a list of dicts.</p>
<p>Prefixes can be found in two ways: from a pool of from a prefix.</p>
<p>From a pool
The <cite>args</cite> argument is set to a dict with key <tt class="xref py py-attr docutils literal"><span class="pre">from-pool</span></tt> set to a
pool spec. This is the pool from which the prefix will be assigned.
Also the key <tt class="xref py py-attr docutils literal"><span class="pre">family</span></tt> needs to be set to the adress family (integer
4 or 6) of the requested prefix.  Optionally, also the key
<tt class="xref py py-attr docutils literal"><span class="pre">prefix_length</span></tt> can be added to the <cite>attr</cite> argument, and will then
override the default prefix length.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;from-pool&#39;</span><span class="p">:</span> <span class="p">{</span> <span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">&#39;CUSTOMER-&#39;</span> <span class="p">},</span>
    <span class="s">&#39;family&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
    <span class="s">&#39;prefix_length&#39;</span><span class="p">:</span> <span class="mi">64</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt>From a prefix</dt>
<dd>Instead of specifying a pool, a prefix which will be searched
for new prefixes can be specified. In <cite>args</cite>, the key
<tt class="xref py py-attr docutils literal"><span class="pre">from-prefix</span></tt> is set to the prefix you want to allocate
from and the key <tt class="xref py py-attr docutils literal"><span class="pre">prefix_length</span></tt> is set to the wanted prefix
length.</dd>
</dl>
<p>Example:</p>
<div class="highlight-python"><pre>args = {
    'from-prefix': '192.0.2.0/24'
    'prefix_length': 27
}</pre>
</div>
<p>The key <tt class="xref py py-attr docutils literal"><span class="pre">count</span></tt> can also be set in the <cite>args</cite> argument to specify
how many prefixes that should be returned. If omitted, the default
value is 1000.</p>
<p>The <a class="reference internal" href="#nipap.nipap.Nipap.find_free_prefix" title="nipap.nipap.Nipap.find_free_prefix"><tt class="xref py py-func docutils literal"><span class="pre">find_free_prefix()</span></tt></a> function is used internally by the
<a class="reference internal" href="#nipap.nipap.Nipap.add_prefix" title="nipap.nipap.Nipap.add_prefix"><tt class="xref py py-func docutils literal"><span class="pre">add_prefix()</span></tt></a> function to find available prefixes from the given
sources.</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.list_asn">
<tt class="descname">list_asn</tt><big>(</big><em>auth</em>, <em>asn={}</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.list_asn" title="Permalink to this definition">¶</a></dt>
<dd><p>List AS numbers</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.list_pool">
<tt class="descname">list_pool</tt><big>(</big><em>auth</em>, <em>spec={}</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.list_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of pools.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>spec</cite> [pool_spec]</dt>
<dd><p class="first last">Specifies what pool(s) to list. Of omitted, all will be listed.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns a list of dicts.</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.list_prefix">
<tt class="descname">list_prefix</tt><big>(</big><em>auth</em>, <em>spec=None</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.list_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>List prefixes matching the <cite>spec</cite>.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>spec</cite> [prefix_spec]</dt>
<dd><p class="first last">Specifies prefixes to list. If omitted, all will be listed.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns a list of dicts.</p>
<p>This is a quite blunt tool for finding prefixes, mostly useful for
fetching data about a single prefix. For more capable alternatives,
see the <a class="reference internal" href="#nipap.nipap.Nipap.search_prefix" title="nipap.nipap.Nipap.search_prefix"><tt class="xref py py-func docutils literal"><span class="pre">search_prefix()</span></tt></a> or <a class="reference internal" href="#nipap.nipap.Nipap.smart_search_prefix" title="nipap.nipap.Nipap.smart_search_prefix"><tt class="xref py py-func docutils literal"><span class="pre">smart_search_prefix()</span></tt></a> functions.</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.list_vrf">
<tt class="descname">list_vrf</tt><big>(</big><em>auth</em>, <em>spec={}</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.list_vrf" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of VRFs matching <cite>spec</cite>.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>spec</cite> [vrf_spec]</dt>
<dd><p class="first last">A VRF specification. If omitted, all VRFs are returned.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns a list of dicts.</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.remove_asn">
<tt class="descname">remove_asn</tt><big>(</big><em>auth</em>, <em>asn</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.remove_asn" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove AS number</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.remove_pool">
<tt class="descname">remove_pool</tt><big>(</big><em>auth</em>, <em>spec</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.remove_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a pool.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>spec</cite> [pool_spec]</dt>
<dd><p class="first last">Specifies what pool(s) to remove.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.remove_prefix">
<tt class="descname">remove_prefix</tt><big>(</big><em>auth</em>, <em>spec</em>, <em>recursive=False</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.remove_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove prefix matching <cite>spec</cite>.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>spec</cite> [prefix_spec]</dt>
<dd><p class="first last">Specifies prefixe to remove.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.remove_vrf">
<tt class="descname">remove_vrf</tt><big>(</big><em>auth</em>, <em>spec</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.remove_vrf" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a VRF.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>spec</cite> [vrf_spec]</dt>
<dd><p class="first last">A VRF specification.</p>
</dd>
</dl>
</li>
</ul>
<p>Remove VRF matching the <cite>spec</cite> argument.</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.search_asn">
<tt class="descname">search_asn</tt><big>(</big><em>auth</em>, <em>query</em>, <em>search_options={}</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.search_asn" title="Permalink to this definition">¶</a></dt>
<dd><p>Search ASNs for entries matching &#8216;query&#8217;</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>query</cite> [dict_to_sql]</dt>
<dd><p class="first last">How the search should be performed.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>search_options</cite> [options_dict]</dt>
<dd><p class="first last">Search options, see below.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns a list of dicts.</p>
<p>The <cite>query</cite> argument passed to this function is designed to be
able to specify how quite advanced search operations should be
performed in a generic format. It is internally expanded to a SQL
WHERE-clause.</p>
<p>The <cite>query</cite> is a dict with three elements, where one specifies the
operation to perform and the two other specifies its arguments. The
arguments can themselves be <cite>query</cite> dicts, to build more complex
queries.</p>
<p>The <tt class="xref py py-attr docutils literal"><span class="pre">operator</span></tt> key specifies what operator should be used for the
comparison. Currently the following operators are supported:</p>
<ul class="simple">
<li><tt class="xref py py-data docutils literal"><span class="pre">and</span></tt> - Logical AND</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">or</span></tt> - Logical OR</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">equals</span></tt> - Equality; =</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">not_equals</span></tt> - Inequality; !=</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">like</span></tt> - SQL LIKE</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">regex_match</span></tt> - Regular expression match</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">regex_not_match</span></tt> - Regular expression not match</li>
</ul>
<p>The <tt class="xref py py-attr docutils literal"><span class="pre">val1</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">val2</span></tt> keys specifies the values which are subjected
to the comparison. <tt class="xref py py-attr docutils literal"><span class="pre">val1</span></tt> can be either any prefix attribute or an
entire query dict. <tt class="xref py py-attr docutils literal"><span class="pre">val2</span></tt> can be either the value you want to
compare the prefix attribute to, or an entire <cite>query</cite> dict.</p>
<p>The search options can also be used to limit the number of rows
returned or set an offset for the result.</p>
<dl class="docutils">
<dt>The following options are available:</dt>
<dd><ul class="first last simple">
<li><tt class="xref py py-attr docutils literal"><span class="pre">max_result</span></tt> - The maximum number of prefixes to return (default <tt class="xref py py-data docutils literal"><span class="pre">50</span></tt>).</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">offset</span></tt> - Offset the result list this many prefixes (default <tt class="xref py py-data docutils literal"><span class="pre">0</span></tt>).</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.search_pool">
<tt class="descname">search_pool</tt><big>(</big><em>auth</em>, <em>query</em>, <em>search_options={}</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.search_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Search pool list for pools matching <cite>query</cite>.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>query</cite> [dict_to_sql]</dt>
<dd><p class="first last">How the search should be performed.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>search_options</cite> [options_dict]</dt>
<dd><p class="first last">Search options, see below.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns a list of dicts.</p>
<p>The <cite>query</cite> argument passed to this function is designed to be
able to specify how quite advanced search operations should be
performed in a generic format. It is internally expanded to a SQL
WHERE-clause.</p>
<p>The <cite>query</cite> is a dict with three elements, where one specifies the
operation to perform and the two other specifies its arguments. The
arguments can themselves be <cite>query</cite> dicts, to build more complex
queries.</p>
<p>The <tt class="xref py py-attr docutils literal"><span class="pre">operator</span></tt> key specifies what operator should be used for the
comparison. Currently the following operators are supported:</p>
<ul class="simple">
<li><tt class="xref py py-data docutils literal"><span class="pre">and</span></tt> - Logical AND</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">or</span></tt> - Logical OR</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">equals</span></tt> - Equality; =</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">not_equals</span></tt> - Inequality; !=</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">like</span></tt> - SQL LIKE</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">regex_match</span></tt> - Regular expression match</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">regex_not_match</span></tt> - Regular expression not match</li>
</ul>
<p>The <tt class="xref py py-attr docutils literal"><span class="pre">val1</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">val2</span></tt> keys specifies the values which are subjected
to the comparison. <tt class="xref py py-attr docutils literal"><span class="pre">val1</span></tt> can be either any pool attribute or an
entire query dict. <tt class="xref py py-attr docutils literal"><span class="pre">val2</span></tt> can be either the value you want to
compare the pool attribute to, or an entire <cite>query</cite> dict.</p>
<p>Example 1 - Find the pool whose name match &#8216;test&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">query</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;operator&#39;</span><span class="p">:</span> <span class="s">&#39;equals&#39;</span><span class="p">,</span>
    <span class="s">&#39;val1&#39;</span><span class="p">:</span> <span class="s">&#39;name&#39;</span><span class="p">,</span>
    <span class="s">&#39;val2&#39;</span><span class="p">:</span> <span class="s">&#39;test&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This will be expanded to the pseudo-SQL query:</p>
<div class="highlight-python"><pre>SELECT * FROM pool WHERE name = 'test'</pre>
</div>
<p>Example 2 - Find pools whose name or description regex matches &#8216;test&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">query</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;operator&#39;</span><span class="p">:</span> <span class="s">&#39;or&#39;</span><span class="p">,</span>
    <span class="s">&#39;val1&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">&#39;operator&#39;</span><span class="p">:</span> <span class="s">&#39;regex_match&#39;</span><span class="p">,</span>
        <span class="s">&#39;val1&#39;</span><span class="p">:</span> <span class="s">&#39;name&#39;</span><span class="p">,</span>
        <span class="s">&#39;val2&#39;</span><span class="p">:</span> <span class="s">&#39;test&#39;</span>
    <span class="p">},</span>
    <span class="s">&#39;val2&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">&#39;operator&#39;</span><span class="p">:</span> <span class="s">&#39;regex_match&#39;</span><span class="p">,</span>
        <span class="s">&#39;val1&#39;</span><span class="p">:</span> <span class="s">&#39;description&#39;</span><span class="p">,</span>
        <span class="s">&#39;val2&#39;</span><span class="p">:</span> <span class="s">&#39;test&#39;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This will be expanded to the pseudo-SQL query:</p>
<div class="highlight-python"><pre>SELECT * FROM pool WHERE name ~* 'test' OR description ~* 'test'</pre>
</div>
<p>The search options can also be used to limit the number of rows
returned or set an offset for the result.</p>
<dl class="docutils">
<dt>The following options are available:</dt>
<dd><ul class="first last simple">
<li><tt class="xref py py-attr docutils literal"><span class="pre">max_result</span></tt> - The maximum number of pools to return (default <tt class="xref py py-data docutils literal"><span class="pre">50</span></tt>).</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">offset</span></tt> - Offset the result list this many pools (default <tt class="xref py py-data docutils literal"><span class="pre">0</span></tt>).</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.search_prefix">
<tt class="descname">search_prefix</tt><big>(</big><em>auth</em>, <em>query</em>, <em>search_options={}</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.search_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Search prefix list for prefixes matching <cite>query</cite>.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>query</cite> [dict_to_sql]</dt>
<dd><p class="first last">How the search should be performed.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>search_options</cite> [options_dict]</dt>
<dd><p class="first last">Search options, see below.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns a list of dicts.</p>
<p>The <cite>query</cite> argument passed to this function is designed to be
able to specify how quite advanced search operations should be
performed in a generic format. It is internally expanded to a SQL
WHERE-clause.</p>
<p>The <cite>query</cite> is a dict with three elements, where one specifies the
operation to perform and the two other specifies its arguments. The
arguments can themselves be <cite>query</cite> dicts, to build more complex
queries.</p>
<p>The <tt class="xref py py-attr docutils literal"><span class="pre">operator</span></tt> key specifies what operator should be used for the
comparison. Currently the following operators are supported:</p>
<ul class="simple">
<li><tt class="xref py py-data docutils literal"><span class="pre">and</span></tt> - Logical AND</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">or</span></tt> - Logical OR</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">equals</span></tt> - Equality; =</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">not_equals</span></tt> - Inequality; !=</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">like</span></tt> - SQL LIKE</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">regex_match</span></tt> - Regular expression match</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">regex_not_match</span></tt> - Regular expression not match</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">contains</span></tt> - IP prefix contains</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">contains_equals</span></tt> - IP prefix contains or is equal to</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">contained_within</span></tt> - IP prefix is contained within</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">contained_within_equals</span></tt> - IP prefix is contained within or equals</li>
</ul>
<p>The <tt class="xref py py-attr docutils literal"><span class="pre">val1</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">val2</span></tt> keys specifies the values which are subjected
to the comparison. <tt class="xref py py-attr docutils literal"><span class="pre">val1</span></tt> can be either any prefix attribute or an
entire query dict. <tt class="xref py py-attr docutils literal"><span class="pre">val2</span></tt> can be either the value you want to
compare the prefix attribute to, or an entire <cite>query</cite> dict.</p>
<p>Example 1 - Find the prefixes which contains 192.0.2.0/24:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">query</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;operator&#39;</span><span class="p">:</span> <span class="s">&#39;contains&#39;</span><span class="p">,</span>
    <span class="s">&#39;val1&#39;</span><span class="p">:</span> <span class="s">&#39;prefix&#39;</span><span class="p">,</span>
    <span class="s">&#39;val2&#39;</span><span class="p">:</span> <span class="s">&#39;192.0.2.0/24&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This will be expanded to the pseudo-SQL query:</p>
<div class="highlight-python"><pre>SELECT * FROM prefix WHERE prefix contains '192.0.2.0/24'</pre>
</div>
<p>Example 2 - Find for all assignments in prefix 192.0.2.0/24:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">query</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;operator&#39;</span><span class="p">:</span> <span class="s">&#39;and&#39;</span><span class="p">,</span>
    <span class="s">&#39;val1&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">&#39;operator&#39;</span><span class="p">:</span> <span class="s">&#39;equals&#39;</span><span class="p">,</span>
        <span class="s">&#39;val1&#39;</span><span class="p">:</span> <span class="s">&#39;type&#39;</span><span class="p">,</span>
        <span class="s">&#39;val2&#39;</span><span class="p">:</span> <span class="s">&#39;assignment&#39;</span>
    <span class="p">},</span>
    <span class="s">&#39;val2&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">&#39;operator&#39;</span><span class="p">:</span> <span class="s">&#39;contained_within&#39;</span><span class="p">,</span>
        <span class="s">&#39;val1&#39;</span><span class="p">:</span> <span class="s">&#39;prefix&#39;</span><span class="p">,</span>
        <span class="s">&#39;val2&#39;</span><span class="p">:</span> <span class="s">&#39;192.0.2.0/24&#39;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This will be expanded to the pseudo-SQL query:</p>
<div class="highlight-python"><pre>SELECT * FROM prefix WHERE (type == 'assignment') AND (prefix contained within '192.0.2.0/24')</pre>
</div>
<p>The <cite>options</cite> argument provides a way to alter the search result a
bit to assist in client implementations. Most options regard parent
and children prefixes, that is the prefixes which contain the
prefix(es) matching the search terms (parents) or the prefixes
which are contained by the prefix(es) matching the search terms.
The search options can also be used to limit the number of rows
returned.</p>
<dl class="docutils">
<dt>The following options are available:</dt>
<dd><ul class="first last simple">
<li><tt class="xref py py-attr docutils literal"><span class="pre">parents_depth</span></tt> - How many levels of parents to return. Set to <tt class="xref py py-data docutils literal"><span class="pre">-1</span></tt> to include all parents.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">children_depth</span></tt> - How many levels of children to return. Set to <tt class="xref py py-data docutils literal"><span class="pre">-1</span></tt> to include all children.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">include_all_parents</span></tt> - Include all parents, no matter what depth is specified.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">include_all_children</span></tt> - Include all children, no matter what depth is specified.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">max_result</span></tt> - The maximum number of prefixes to return (default <tt class="xref py py-data docutils literal"><span class="pre">50</span></tt>).</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">offset</span></tt> - Offset the result list this many prefixes (default <tt class="xref py py-data docutils literal"><span class="pre">0</span></tt>).</li>
</ul>
</dd>
</dl>
<p>The options above gives the possibility to specify how many levels
of parent and child prefixes to return in addition to the prefixes
that actually matched the search terms. This is done by setting the
<tt class="xref py py-attr docutils literal"><span class="pre">parents_depth</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">children</span> <span class="pre">depth</span></tt> keys in the
<cite>search_options</cite> dict to an integer value.  In addition to this it
is possible to get all all parents and/or children included in the
result set even though they are outside the limits set with
<tt class="xref py py-attr docutils literal"><span class="pre">*_depth</span></tt>.  The extra prefixes included will have the
attribute <tt class="xref py py-attr docutils literal"><span class="pre">display</span></tt> set to <tt class="xref py py-data docutils literal"><span class="pre">false</span></tt> while the other ones
(the actual search result togther with the ones included due to
given depth) <tt class="xref py py-attr docutils literal"><span class="pre">display</span></tt> set to <tt class="xref py py-data docutils literal"><span class="pre">true</span></tt>. This feature is
usable obtain search results with some context given around them,
useful for example when displaying prefixes in a tree without the
need to implement client side IP address logic.</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.search_vrf">
<tt class="descname">search_vrf</tt><big>(</big><em>auth</em>, <em>query</em>, <em>search_options={}</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.search_vrf" title="Permalink to this definition">¶</a></dt>
<dd><p>Search VRF list for VRFs matching <cite>query</cite>.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>query</cite> [dict_to_sql]</dt>
<dd><p class="first last">How the search should be performed.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>search_options</cite> [options_dict]</dt>
<dd><p class="first last">Search options, see below.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns a list of dicts.</p>
<p>The <cite>query</cite> argument passed to this function is designed to be
able to specify how quite advanced search operations should be
performed in a generic format. It is internally expanded to a SQL
WHERE-clause.</p>
<p>The <cite>query</cite> is a dict with three elements, where one specifies the
operation to perform and the two other specifies its arguments. The
arguments can themselves be <cite>query</cite> dicts, to build more complex
queries.</p>
<p>The <tt class="xref py py-attr docutils literal"><span class="pre">operator</span></tt> key specifies what operator should be used for the
comparison. Currently the following operators are supported:</p>
<ul class="simple">
<li><tt class="xref py py-data docutils literal"><span class="pre">and</span></tt> - Logical AND</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">or</span></tt> - Logical OR</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">equals</span></tt> - Equality; =</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">not_equals</span></tt> - Inequality; !=</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">like</span></tt> - SQL LIKE</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">regex_match</span></tt> - Regular expression match</li>
<li><tt class="xref py py-data docutils literal"><span class="pre">regex_not_match</span></tt> - Regular expression not match</li>
</ul>
<p>The <tt class="xref py py-attr docutils literal"><span class="pre">val1</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">val2</span></tt> keys specifies the values which are subjected
to the comparison. <tt class="xref py py-attr docutils literal"><span class="pre">val1</span></tt> can be either any prefix attribute or an
entire query dict. <tt class="xref py py-attr docutils literal"><span class="pre">val2</span></tt> can be either the value you want to
compare the prefix attribute to, or an entire <cite>query</cite> dict.</p>
<p>Example 1 - Find the VRF whose VRF match &#8216;65000:123&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">query</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;operator&#39;</span><span class="p">:</span> <span class="s">&#39;equals&#39;</span><span class="p">,</span>
    <span class="s">&#39;val1&#39;</span><span class="p">:</span> <span class="s">&#39;vrf&#39;</span><span class="p">,</span>
    <span class="s">&#39;val2&#39;</span><span class="p">:</span> <span class="s">&#39;65000:123&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This will be expanded to the pseudo-SQL query:</p>
<div class="highlight-python"><pre>SELECT * FROM vrf WHERE vrf = '65000:123'</pre>
</div>
<p>Example 2 - Find vrf whose name or description regex matches &#8216;test&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">query</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;operator&#39;</span><span class="p">:</span> <span class="s">&#39;or&#39;</span><span class="p">,</span>
    <span class="s">&#39;val1&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">&#39;operator&#39;</span><span class="p">:</span> <span class="s">&#39;regex_match&#39;</span><span class="p">,</span>
        <span class="s">&#39;val1&#39;</span><span class="p">:</span> <span class="s">&#39;name&#39;</span><span class="p">,</span>
        <span class="s">&#39;val2&#39;</span><span class="p">:</span> <span class="s">&#39;test&#39;</span>
    <span class="p">},</span>
    <span class="s">&#39;val2&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">&#39;operator&#39;</span><span class="p">:</span> <span class="s">&#39;regex_match&#39;</span><span class="p">,</span>
        <span class="s">&#39;val1&#39;</span><span class="p">:</span> <span class="s">&#39;description&#39;</span><span class="p">,</span>
        <span class="s">&#39;val2&#39;</span><span class="p">:</span> <span class="s">&#39;test&#39;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This will be expanded to the pseudo-SQL query:</p>
<div class="highlight-python"><pre>SELECT * FROM vrf WHERE name ~* 'test' OR description ~* 'test'</pre>
</div>
<p>The search options can also be used to limit the number of rows
returned or set an offset for the result.</p>
<dl class="docutils">
<dt>The following options are available:</dt>
<dd><ul class="first last simple">
<li><tt class="xref py py-attr docutils literal"><span class="pre">max_result</span></tt> - The maximum number of prefixes to return (default <tt class="xref py py-data docutils literal"><span class="pre">50</span></tt>).</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">offset</span></tt> - Offset the result list this many prefixes (default <tt class="xref py py-data docutils literal"><span class="pre">0</span></tt>).</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.smart_search_asn">
<tt class="descname">smart_search_asn</tt><big>(</big><em>auth</em>, <em>query_str</em>, <em>search_options={}</em>, <em>extra_query=None</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.smart_search_asn" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a smart search operation among AS numbers</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>query_str</cite> [string]</dt>
<dd><p class="first last">Search string</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>search_options</cite> [options_dict]</dt>
<dd><p class="first last">Search options. See <a class="reference internal" href="#nipap.nipap.Nipap.search_asn" title="nipap.nipap.Nipap.search_asn"><tt class="xref py py-func docutils literal"><span class="pre">search_asn()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>extra_query</cite> [dict_to_sql]</dt>
<dd><p class="first last">Extra search terms, will be AND:ed together with what is
extracted from the query string.</p>
</dd>
</dl>
</li>
</ul>
<dl class="docutils">
<dt>Return a dict with three elements:</dt>
<dd><ul class="first simple">
<li><tt class="xref py py-attr docutils literal"><span class="pre">interpretation</span></tt> - How the query string was interpreted.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">search_options</span></tt> - Various search_options.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">result</span></tt> - The search result.</li>
</ul>
<p>The <tt class="xref py py-attr docutils literal"><span class="pre">interpretation</span></tt> is given as a list of dicts, each
explaining how a part of the search key was interpreted (ie. what
ASN attribute the search operation was performed on).</p>
<p class="last">The <tt class="xref py py-attr docutils literal"><span class="pre">result</span></tt> is a list of dicts containing the search result.</p>
</dd>
</dl>
<p>The smart search function tries to convert the query from a text
string to a <cite>query</cite> dict which is passed to the
<a class="reference internal" href="#nipap.nipap.Nipap.search_asn" title="nipap.nipap.Nipap.search_asn"><tt class="xref py py-func docutils literal"><span class="pre">search_asn()</span></tt></a> function.  If multiple search keys are
detected, they are combined with a logical AND.</p>
<p>See the <a class="reference internal" href="#nipap.nipap.Nipap.search_asn" title="nipap.nipap.Nipap.search_asn"><tt class="xref py py-func docutils literal"><span class="pre">search_asn()</span></tt></a> function for an explanation of the
<cite>search_options</cite> argument.</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.smart_search_pool">
<tt class="descname">smart_search_pool</tt><big>(</big><em>auth</em>, <em>query_str</em>, <em>search_options={}</em>, <em>extra_query=None</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.smart_search_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a smart search on pool list.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>query_str</cite> [string]</dt>
<dd><p class="first last">Search string</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>search_options</cite> [options_dict]</dt>
<dd><p class="first last">Search options. See <a class="reference internal" href="#nipap.nipap.Nipap.search_pool" title="nipap.nipap.Nipap.search_pool"><tt class="xref py py-func docutils literal"><span class="pre">search_pool()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>extra_query</cite> [dict_to_sql]</dt>
<dd><p class="first last">Extra search terms, will be AND:ed together with what is
extracted from the query string.</p>
</dd>
</dl>
</li>
</ul>
<dl class="docutils">
<dt>Return a dict with three elements:</dt>
<dd><ul class="first simple">
<li><tt class="xref py py-attr docutils literal"><span class="pre">interpretation</span></tt> - How the query string was interpreted.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">search_options</span></tt> - Various search_options.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">result</span></tt> - The search result.</li>
</ul>
<p>The <tt class="xref py py-attr docutils literal"><span class="pre">interpretation</span></tt> is given as a list of dicts, each
explaining how a part of the search key was interpreted (ie. what
pool attribute the search operation was performed on).</p>
<p class="last">The <tt class="xref py py-attr docutils literal"><span class="pre">result</span></tt> is a list of dicts containing the search result.</p>
</dd>
</dl>
<p>The smart search function tries to convert the query from a text
string to a <cite>query</cite> dict which is passed to the
<a class="reference internal" href="#nipap.nipap.Nipap.search_pool" title="nipap.nipap.Nipap.search_pool"><tt class="xref py py-func docutils literal"><span class="pre">search_pool()</span></tt></a> function.  If multiple search keys are
detected, they are combined with a logical AND.</p>
<p>It will basically just take each search term and try to match it
against the name or description column with regex match.</p>
<p>See the <a class="reference internal" href="#nipap.nipap.Nipap.search_pool" title="nipap.nipap.Nipap.search_pool"><tt class="xref py py-func docutils literal"><span class="pre">search_pool()</span></tt></a> function for an explanation of the
<cite>search_options</cite> argument.</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.smart_search_prefix">
<tt class="descname">smart_search_prefix</tt><big>(</big><em>auth</em>, <em>query_str</em>, <em>search_options={}</em>, <em>extra_query=None</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.smart_search_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a smart search on prefix list.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>query_str</cite> [string]</dt>
<dd><p class="first last">Search string</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>search_options</cite> [options_dict]</dt>
<dd><p class="first last">Search options. See <a class="reference internal" href="#nipap.nipap.Nipap.search_prefix" title="nipap.nipap.Nipap.search_prefix"><tt class="xref py py-func docutils literal"><span class="pre">search_prefix()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>extra_query</cite> [dict_to_sql]</dt>
<dd><p class="first last">Extra search terms, will be AND:ed together with what is
extracted from the query string.</p>
</dd>
</dl>
</li>
</ul>
<dl class="docutils">
<dt>Return a dict with three elements:</dt>
<dd><ul class="first simple">
<li><tt class="xref py py-attr docutils literal"><span class="pre">interpretation</span></tt> - How the query string was interpreted.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">search_options</span></tt> - Various search_options.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">result</span></tt> - The search result.</li>
</ul>
<p>The <tt class="xref py py-attr docutils literal"><span class="pre">interpretation</span></tt> is given as a list of dicts, each
explaining how a part of the search key was interpreted (ie. what
prefix attribute the search operation was performed on).</p>
<p class="last">The <tt class="xref py py-attr docutils literal"><span class="pre">result</span></tt> is a list of dicts containing the search result.</p>
</dd>
</dl>
<p>The smart search function tries to convert the query from a text
string to a <cite>query</cite> dict which is passed to the
<a class="reference internal" href="#nipap.nipap.Nipap.search_prefix" title="nipap.nipap.Nipap.search_prefix"><tt class="xref py py-func docutils literal"><span class="pre">search_prefix()</span></tt></a> function.  If multiple search keys are
detected, they are combined with a logical AND.</p>
<p>It tries to automatically detect IP addresses and prefixes and put
these into the <cite>query</cite> dict with &#8220;contains_within&#8221; operators and so
forth.</p>
<p>See the <a class="reference internal" href="#nipap.nipap.Nipap.search_prefix" title="nipap.nipap.Nipap.search_prefix"><tt class="xref py py-func docutils literal"><span class="pre">search_prefix()</span></tt></a> function for an explanation of the
<cite>search_options</cite> argument.</p>
</dd></dl>

<dl class="method">
<dt id="nipap.nipap.Nipap.smart_search_vrf">
<tt class="descname">smart_search_vrf</tt><big>(</big><em>auth</em>, <em>query_str</em>, <em>search_options={}</em>, <em>extra_query=None</em><big>)</big><a class="headerlink" href="#nipap.nipap.Nipap.smart_search_vrf" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a smart search on VRF list.</p>
<ul>
<li><dl class="first docutils">
<dt><cite>auth</cite> [BaseAuth]</dt>
<dd><p class="first last">AAA options.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>query_str</cite> [string]</dt>
<dd><p class="first last">Search string</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>search_options</cite> [options_dict]</dt>
<dd><p class="first last">Search options. See <a class="reference internal" href="#nipap.nipap.Nipap.search_vrf" title="nipap.nipap.Nipap.search_vrf"><tt class="xref py py-func docutils literal"><span class="pre">search_vrf()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>extra_query</cite> [dict_to_sql]</dt>
<dd><p class="first last">Extra search terms, will be AND:ed together with what is
extracted from the query string.</p>
</dd>
</dl>
</li>
</ul>
<dl class="docutils">
<dt>Return a dict with three elements:</dt>
<dd><ul class="first simple">
<li><tt class="xref py py-attr docutils literal"><span class="pre">interpretation</span></tt> - How the query string was interpreted.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">search_options</span></tt> - Various search_options.</li>
<li><tt class="xref py py-attr docutils literal"><span class="pre">result</span></tt> - The search result.</li>
</ul>
<p>The <tt class="xref py py-attr docutils literal"><span class="pre">interpretation</span></tt> is given as a list of dicts, each
explaining how a part of the search key was interpreted (ie. what
VRF attribute the search operation was performed on).</p>
<p class="last">The <tt class="xref py py-attr docutils literal"><span class="pre">result</span></tt> is a list of dicts containing the search result.</p>
</dd>
</dl>
<p>The smart search function tries to convert the query from a text
string to a <cite>query</cite> dict which is passed to the
<a class="reference internal" href="#nipap.nipap.Nipap.search_vrf" title="nipap.nipap.Nipap.search_vrf"><tt class="xref py py-func docutils literal"><span class="pre">search_vrf()</span></tt></a> function.  If multiple search keys are
detected, they are combined with a logical AND.</p>
<p>It will basically just take each search term and try to match it
against the name or description column with regex match or the VRF
column with an exact match.</p>
<p>See the <a class="reference internal" href="#nipap.nipap.Nipap.search_vrf" title="nipap.nipap.Nipap.search_vrf"><tt class="xref py py-func docutils literal"><span class="pre">search_vrf()</span></tt></a> function for an explanation of the
<cite>search_options</cite> argument.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="nipap.nipap.NipapDuplicateError">
<em class="property">exception </em><tt class="descclassname">nipap.nipap.</tt><tt class="descname">NipapDuplicateError</tt><a class="headerlink" href="#nipap.nipap.NipapDuplicateError" title="Permalink to this definition">¶</a></dt>
<dd><p>The passed object violates unique constraints</p>
<p>For example, create a VRF with a name of an already existing one.</p>
</dd></dl>

<dl class="exception">
<dt id="nipap.nipap.NipapError">
<em class="property">exception </em><tt class="descclassname">nipap.nipap.</tt><tt class="descname">NipapError</tt><a class="headerlink" href="#nipap.nipap.NipapError" title="Permalink to this definition">¶</a></dt>
<dd><p>NIPAP base error class.</p>
</dd></dl>

<dl class="exception">
<dt id="nipap.nipap.NipapExtraneousInputError">
<em class="property">exception </em><tt class="descclassname">nipap.nipap.</tt><tt class="descname">NipapExtraneousInputError</tt><a class="headerlink" href="#nipap.nipap.NipapExtraneousInputError" title="Permalink to this definition">¶</a></dt>
<dd><p>Extraneous input.</p>
<p>Most input is passed in dicts, this could mean an unknown key in a dict.</p>
</dd></dl>

<dl class="exception">
<dt id="nipap.nipap.NipapInputError">
<em class="property">exception </em><tt class="descclassname">nipap.nipap.</tt><tt class="descname">NipapInputError</tt><a class="headerlink" href="#nipap.nipap.NipapInputError" title="Permalink to this definition">¶</a></dt>
<dd><p>Erroneous input.</p>
<p>A general input error.</p>
</dd></dl>

<dl class="exception">
<dt id="nipap.nipap.NipapMissingInputError">
<em class="property">exception </em><tt class="descclassname">nipap.nipap.</tt><tt class="descname">NipapMissingInputError</tt><a class="headerlink" href="#nipap.nipap.NipapMissingInputError" title="Permalink to this definition">¶</a></dt>
<dd><p>Missing input.</p>
<p>Most input is passed in dicts, this could mean a missing key in a dict.</p>
</dd></dl>

<dl class="exception">
<dt id="nipap.nipap.NipapNoSuchOperatorError">
<em class="property">exception </em><tt class="descclassname">nipap.nipap.</tt><tt class="descname">NipapNoSuchOperatorError</tt><a class="headerlink" href="#nipap.nipap.NipapNoSuchOperatorError" title="Permalink to this definition">¶</a></dt>
<dd><p>A non existent operator was specified.</p>
</dd></dl>

<dl class="exception">
<dt id="nipap.nipap.NipapNonExistentError">
<em class="property">exception </em><tt class="descclassname">nipap.nipap.</tt><tt class="descname">NipapNonExistentError</tt><a class="headerlink" href="#nipap.nipap.NipapNonExistentError" title="Permalink to this definition">¶</a></dt>
<dd><p>A non existent object was specified</p>
<p>For example, try to get a prefix from a pool which doesn&#8217;t exist.</p>
</dd></dl>

<dl class="exception">
<dt id="nipap.nipap.NipapValueError">
<em class="property">exception </em><tt class="descclassname">nipap.nipap.</tt><tt class="descname">NipapValueError</tt><a class="headerlink" href="#nipap.nipap.NipapValueError" title="Permalink to this definition">¶</a></dt>
<dd><p>Something wrong with a value</p>
<p>For example, trying to send an integer when an IP address is expected.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">NIPAP API</a><ul>
<li><a class="reference internal" href="#vrf">VRF</a><ul>
<li><a class="reference internal" href="#vrf-attributes">VRF attributes</a></li>
<li><a class="reference internal" href="#vrf-functions">VRF functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#prefix">Prefix</a><ul>
<li><a class="reference internal" href="#prefix-attributes">Prefix attributes</a></li>
<li><a class="reference internal" href="#prefix-functions">Prefix functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pool">Pool</a><ul>
<li><a class="reference internal" href="#pool-attributes">Pool attributes</a></li>
<li><a class="reference internal" href="#pool-functions">Pool functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#asn">ASN</a><ul>
<li><a class="reference internal" href="#asn-attributes">ASN attributes</a></li>
<li><a class="reference internal" href="#asn-functions">ASN functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-spec">The &#8216;spec&#8217;</a></li>
<li><a class="reference internal" href="#authorization-accounting">Authorization &amp; accounting</a></li>
<li><a class="reference internal" href="#classes">Classes</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="design.html"
                        title="previous chapter">Design choices</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="xmlrpc.html"
                        title="next chapter">XML-RPC glue class</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="xmlrpc.html" title="XML-RPC glue class"
             >next</a> |</li>
        <li class="right" >
          <a href="design.html" title="Design choices"
             >previous</a> |</li>
        <li><a href="index.html">NIPAP 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Kristian Larsson &lt;kll@tele2.net&gt;, Lukas Garberg &lt;lukas@tele2.net&gt;.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>